<!-- Grafico ordini per giorno (HTML + CSS + JS minimal, con dati demo) -->

<div class="chart-card">
  <div class="chart-header">
    <div class="chart-title">Ordini per giorno</div>
    <div class="chart-sub">ultimi 10 giorni â€¢ dati demo</div>
  </div>
  <div class="chart-body">
    <canvas id="orders-chart"></canvas>
  </div>
</div>

<style>
.chart-card{
  width:100%;
  background:#fff;
  color:#111;
  border-radius:14px;
  border:1px solid rgba(0,0,0,.08);
  box-shadow:0 10px 24px rgba(0,0,0,.15);
  padding:12px 14px 10px;
  display:flex;
  flex-direction:column;
}
.chart-header{display:flex;flex-direction:column;gap:2px;margin-bottom:8px}
.chart-title{font-size:14px;font-weight:800;letter-spacing:.04em;text-transform:uppercase}
.chart-sub{font-size:11px;opacity:.7}
.chart-body{position:relative;width:100%;height:160px}
#orders-chart{width:100%;height:100%;display:block}
</style>

<script>
// ===== Demo data (ultimi 10 giorni) =====
const demoOrdersByDay = [
  { date: '2025-11-08', count: 6 },
  { date: '2025-11-09', count: 11 },
  { date: '2025-11-10', count: 4 },
  { date: '2025-11-11', count: 9 },
  { date: '2025-11-12', count: 7 },
  { date: '2025-11-13', count: 14 },
  { date: '2025-11-14', count: 12 },
  { date: '2025-11-15', count: 5 },
  { date: '2025-11-16', count: 10 },
  { date: '2025-11-17', count: 8 }
];

let ordersChartData = demoOrdersByDay.slice();

function getChartCanvasAndCtx(){
  const canvas = document.getElementById('orders-chart');
  if (!canvas) return {};
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  let rect = canvas.getBoundingClientRect();

  // Se per qualche motivo non ha ancora dimensioni, forziamo un fallback
  if (!rect.width || !rect.height){
    canvas.style.width = '100%';
    canvas.style.height = '160px';
    rect = { width: canvas.clientWidth || 320, height: canvas.clientHeight || 160 };
  }

  canvas.width  = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { canvas, ctx, width: rect.width, height: rect.height };
}

function drawOrdersChart(data){
  const { ctx, width, height } = getChartCanvasAndCtx();
  if (!ctx || !width || !height) return;

  ctx.clearRect(0, 0, width, height);

  const padding = { top: 10, right: 10, bottom: 22, left: 30 };
  const w = Math.max(10, width  - padding.left - padding.right);
  const h = Math.max(10, height - padding.top  - padding.bottom);

  // Background soft
  ctx.fillStyle = '#fafafa';
  ctx.fillRect(padding.left, padding.top, w, h);

  const maxCount = Math.max(1, ...data.map(d => d.count));
  const steps = Math.min(maxCount, 4);

  // Grid
  ctx.strokeStyle = 'rgba(0,0,0,0.08)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i = 0; i <= steps; i++){
    const y = padding.top + h - (h * i / steps);
    ctx.moveTo(padding.left, y + 0.5);
    ctx.lineTo(padding.left + w, y + 0.5);
  }
  ctx.stroke();

  // Y labels
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.font = '10px Verdana, sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for (let i = 0; i <= steps; i++){
    const value = Math.round(maxCount * i / steps);
    const y = padding.top + h - (h * i / steps);
    ctx.fillText(String(value), padding.left - 4, y);
  }

  const n = data.length;
  if (!n) return;

  const barGap = 6;
  const barWidth = Math.max(4, (w - barGap * (n + 1)) / n);

  data.forEach((d, i) => {
    const x = padding.left + barGap + i * (barWidth + barGap);
    const barH = d.count / maxCount * h;
    const y = padding.top + h - barH;

    const grad = ctx.createLinearGradient(0, y, 0, y + barH);
    grad.addColorStop(0, '#a01212');
    grad.addColorStop(1, '#770505');

    ctx.fillStyle = grad;
    ctx.beginPath();
    const r = 4;
    ctx.moveTo(x, y + r);
    ctx.arcTo(x, y, x + barWidth, y, r);
    ctx.arcTo(x + barWidth, y, x + barWidth, y + barH, r);
    ctx.lineTo(x + barWidth, y + barH);
    ctx.lineTo(x, y + barH);
    ctx.closePath();
    ctx.fill();
  });

  // X labels
  ctx.fillStyle = 'rgba(0,0,0,0.65)';
  ctx.font = '9px Verdana, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  data.forEach((d, i) => {
    const xCenter = padding.left + barGap + i * (barWidth + barGap) + barWidth / 2;
    const [yyyy, mm, dd] = d.date.split('-');
    const label = `${dd}/${mm}`;
    ctx.fillText(label, xCenter, padding.top + h + 4);
  });
}

// API per collegare ORDERS reali in futuro
function updateOrdersChart(orders){
  const map = new Map();
  for (const o of orders || []){
    if (!o.date) continue;
    map.set(o.date, (map.get(o.date) || 0) + 1);
  }
  const rows = Array.from(map.entries())
    .map(([date, count]) => ({ date, count }))
    .sort((a,b) => a.date.localeCompare(b.date))
    .slice(-10);

  ordersChartData = rows.length ? rows : demoOrdersByDay.slice();
  drawOrdersChart(ordersChartData);
}

function initOrdersChart(){
  drawOrdersChart(ordersChartData);
}

if (document.readyState === 'loading'){
  document.addEventListener('DOMContentLoaded', initOrdersChart);
} else {
  initOrdersChart();
}

window.addEventListener('resize', () => {
  drawOrdersChart(ordersChartData);
});
</script>
